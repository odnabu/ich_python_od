# Tatiana Kletsovka
# \033[0;__;__m \033[m   or   \033[1;__;__m \033[m
# print('#' * 115)      # Для разделения блоков на листе с кодом:
# ###################################################################################################################
# 13.02.25
# Python 42: Исключения: обработка ошибок.
# Video Lesson 42: https://player.vimeo.com/video/1056392539?h=d82ccb0b86
# ###################################################################################################################
# def input_numb_list():
#     numb_list = [int(x) for x in input('Enter a list of numbers separated by space: ').split()]
#     return numb_list
# ------------------------ SHORTCUTS ------------------------
# Ctrl + W - выделить текущий блок. если нажимать это сочетание дальше, то будут выделяться родительские блоки.
# Ctrl+Y - Удаление всей строки. Кстати, команда копирования Ctrl+C без выделения также работает для всей строки.
# Alt+Enter - Привести код к принятым стандартам (для Python - PEP8).
# Ctrl+R — Изменить название класса/функции и т. п. по всему проекту.
# -----------------------------------------------------------
print('.' * 145)



# %%%%%%%%%%%%%%%%%%%%%%%%%%%_____________   Исключения: обработка ошибок   ______________%%%%%%%%%%%%%%%%%%%%%%%%%%%

# See here https://tatyderb.gitbooks.io/python-express-course/content/chapter_exception/3_tree.html

# __________ Исключения __________
#  - события, которые возникают во время выполнения программы и приводят к изменению обычного хода
# выполнения программы.
# __ Исключения могут возникать из-за:
#       - Ошибок в коде.
#       - Непредвиденных условий.
# __ Использование исключений позволяет:
#       - логически разделить обработку ошибок от основного кода программы.
#       - предоставить возможность обработки и возврата из исключительных ситуаций.

# _____ raise _____
# - функция, которая позволяет добавить исключение вручную. Т.е. вызов или инициализация выполнения ошибки!
# def divide(x, y):
#     if y == 0:
#         raise ValueError("Деление на ноль недопустимо")
#     return x / y

# БЕЗ ошибки:
# def divide(x, y):
#     # if y == 0:
#     #     raise ValueError("Деление на ноль недопустимо")
#     return x / y
# print(divide(6, 3))

# def divide(x, y):
#     if y < 0:
#         raise ValueError("Не работаем с отрицательными!")
#     return x / y
# print(divide(6, -3))

# __________ Иерархия исключений __________
# — исключения образуют иерархию классов, где каждый класс исключения является наследником базового класса
# BaseException. Это позволяет обрабатывать исключения различных типов и выполнять специфические действия в
# зависимости от типа исключения.

# _____ try-except _____
# — это оператор, который позволяет обрабатывать исключения в коде:
#       - Блок try содержит код, который может вызвать исключение.
#       - Блок except определяет, как обрабатывать это исключение.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# __ NB! __ Если исключение возникает в блоке try, то выполнение кода в блоке try ПРЕКРАЩАЕТСЯ!, и
#           управление передается в соответствующий блок except.
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# x = 10 / 0                      # ZeroDivisionError: division by zero
# print(x)

# __ 1-st Variant __
# try:
#     x = 10 / 0
#     print(x)
# except ZeroDivisionError:
#     notice = f"\033[31mОшибка деления на ноль\033[m в выражении x."
#     print(notice)
#
# print('-' * (len(notice) - len('\033[31m\033[m')))         # После try код НЕ прервется и продолжит корректно работать.

# __ 2-nd Variant __
# x = 10 / 0
# try:
#     print(x)
# except ZeroDivisionError:
#     notice = f"\033[31mОшибка деления на ноль\033[m в выражении x."
#     print(notice)
#
# print('-' * (len(notice) - len('\033[31m\033[m')))            # А вот тут будет ОШИБКА, которая отработана НЕ будет и код дальше работать НЕ будет.

# __________ Обработка нескольких исключений __________
# В одной конструкции try-except можно обработать несколько различных исключений.

# __ 1-st Variant __
# try:
#     x = int("abc")                                       # Ошибки НЕ будет и код будет работать дальше корректно.
# except ValueError:
#     print("Ошибка преобразования строки в число.")
# except TypeError:
#     print("Ошибка типа данных.")
#
# print("Hi")

# __ 2-nd Variant __
# try:
#     [1, 2][5]                                    # Будет ОШИБКА обращения к несуществующему индексу IndexError и -->
#     x = int("abc")                               # -->  код дальше работать НЕ будет!
# except ValueError:
#     print("Ошибка преобразования строки в число")
# except TypeError:
#     print("Ошибка типа данных")
#
# print("Hi")

# __ 3-d Variant __
# try:
#     x = int("abc")                                       # Ошибки НЕ будет и код будет работать дальше корректно, т.к.
#     [1, 2][5]                                            # первая ошибка уже отработана и к следуюущей перехода НЕ будет.
# except ValueError:
#     print("Ошибка преобразования строки в число.")
# except TypeError:
#     print("Ошибка типа данных.")
#
# print("Hi")

# Можно делать вложенные try-except:
# try:
#     x = int("abc")                             # Ошибки НЕ будет и код будет работать дальше корректно, т.к.
#                                                # первая ошибка уже отработана и к следуюущей перехода НЕ будет.
# except ValueError:
#     print("Ошибка преобразования строки в число.")
#     try:
#         [1, 2][5]
#     except IndexError:
#         print("ОШИБКА обращения к несуществующему индексу.")
# except TypeError:
#     print("Ошибка типа данных.")
#
# print("Hi")

# __________ Иерархия исключений __________
# Будет искать 1-ый подходящий обработчик. Потому вариант ниже НЕправильный!
# try:
#     x = int("abc")
# except Exception:
#     print("Какая-то ошибка.")
# except ValueError:
#     print("Ошибка преобразования строки в число.")

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# ПРАВИЛЬНО оформлять except-ы в таком порядке, т.е. то что выше по иерархии - ниже по коду в try-except:
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# try:
#     # x = int("abc")
#     10 / 0
# except ValueError:
#     print("Ошибка преобразования строки в число.")
# except Exception:
#     print("Какая-то ошибка.")

# _____ finally _____
# - это ключевое слово, которое используется вместе с блоком try-except и позволяет определить код, который будет
#   выполнен в любом случае, независимо от возникновения исключений.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# __ NB! __  Блок finally выполняется ВСЕГДА после выполнения блока try-except, даже если возникло исключение.
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# __ 1-st Variant __
# file = open("data.txt", "r")
# try:
#     file.write("Lorum Ipsum")
# except:
#     print("Запись не удалась")
# finally:                                     # finally гарантирует безопасное завершение процесса.
#     file.close()

# __ 2-nd Variant __ - with ERROR
# try:                                         # ERROR! --- NameError: name 'file' is not defined
#     file = open("data_bububu.txt", "r")
#     file.read()
# except:
#     print("Запись не удалась.")
# finally:
#     file.close()

# __ 2-nd Variant __ - without ERROR
# file = None
# try:                                         # ERROR! --- NameError: name 'file' is not defined
#     file = open("data_bububu.txt", "r")
#     file.read()
# except:
#     print("Запись не удалась.")
# finally:
#     if file:
#         file.close()


# _____ else _____ Video 1:14:20
# else в контексте обработки ошибок: Ключевое слово else в блоке try-except используется для определения кода,
# который будет выполнен только в случае, если в блоке try НЕ возникло исключений.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# __ NB! __ Блок else выполняется только в той ситуации, если выполнение произошло БЕЗ проблем.
#           + Video 1:15:30 -- else позволяет удобно разложить логику программы, даже если ошибок не возникнет.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# __ NB! __ ПРАВИЛО try-except (Video 1:15:50):     в блоке try желательно указывать только тот код,
#                   который вызовет ошибку! Далее прописываем действия, которые могут быть при этой ошибке.
#                   И после этого код, который связан с возможной ошибкой, но котрой может не быть,
#                   мы выполняем в else, чтобы отделить логику. И если except срабатывает, то else просто
#                   игнорируется.
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# print("-----\\/\\/------")
# try:
#     x = 10 / 2                              # x = 10 / 2 -- >
# except ZeroDivisionError:
#     print("Ошибка деления на ноль.")
# else:                                       # else НЕ выполнится при ошибке.
#     print("Результат: ", x)                 # -- > Выводит "Результат: 5.0"
# finally:
#     print("Finally :-) ")

# Возникновение ошибки без блока else:
# print("-----\\/\\/------")
# try:
#     x = 10 / 0
# except ZeroDivisionError:
#     print("Ошибка деления на ноль.")
# # else:
# print("Результат: ", x)              # Выводит ERROR! Потому что обращение к переменной, котрой НЕ существует.

# Без ошибки в предыдущем примере кода с else:
# print("-----\\/\\/------")
# try:
#     x = 10 / 0
# except ZeroDivisionError:
#     print("Ошибка деления на ноль.")
# else:
#     print("Результат: ", x)              # Ошибки НЕ будет.

# __ NB! __ Отличие else от finally: else НЕ выполнится при ошибке, тогда как finally выполняется ВСЕГДА.

# _____ ПОРЯДОК выполнения в функции _____       finally по иерархии ВЫШЕ чем return!
# def func():
#    try:
#        10 / 0
#    except ZeroDivisionError:
#        print("Error.")
#        return
#    finally:                         # finally - выполняется в ЛЮБОМ СЛУЧАЕ!
#        print("finally :-) ")        # Перехватывает на СЕБЯ выполнение и только потом отдает свою работу return!
#
# func()
# print("----")


# ______  Task 1  ____________________________________________________________________________________________________
# Напишите программу, которая будет считывать данные из файла names.txt и будет формировать список
# кортежей из пяти полей: фамилия, имя, год рождения, курс и баллы.
# Обработайте следующие ошибки: файла не существует, нельзя считать из файла, возраст не является числом,
# возраст отсутствует, неверное количество данных и т.п.
#       Пример входного файла:
#           Ivanov Ivan     1980 2 80
#           Smith Ann       2000 1 67
#           Petrov Petro    1999 1 90 43
#           Schmidt Marta   1976 3
#           Johnson John    1965g 5 99
#           Archer Lenard   1978 v5 51

# 1) читаем файл, причем лучше с конструкцией with.
# 2) закрыть файл.

# file = None
# try:
#     file = open("names.txt")
# except FileNotFoundError as e:
#     print(e)
# else:
#     data = file.readlines()
#     try:
#         for el in data:
#             int(el[3])
#         # for line in data:
#         #     line = line.strip().split()
#         #     if len(line) == 5:
#         #         name, surname, year, grade, points = line
#         #         year = int(year)
#         #         grade = int(grade)
#         #         points = int(points)
#         #         print(name, surname, year, grade, points)
#     except ValueError as e:
#         print(e)
# finally:
#     if file:
#         file.close()