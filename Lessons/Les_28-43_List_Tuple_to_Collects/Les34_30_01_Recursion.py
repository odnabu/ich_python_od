# Tatiana Kletsovka
# \033[0;__;__m \033[m   or   \033[1;__;__m \033[m
# print('#' * 115)      # Для разделения блоков на листе с кодом:
# ###################################################################################################################
# 30.01.25
# Python 34: Рекурсия.
# ###################################################################################################################
# def input_numb_list():
#     numb_list = [int(x) for x in input('Enter a list of numbers separated by space: ').split()]
#     return numb_list
print('.' * 120)


# _________________________ Review of previously covered material _________________________
# LAMBDA func:
# words = ["First day", "6 day 2", "day 3", "day 0", "1 monday", "tuesday"]
# #           f            6           d       d          1          t
# words.sort(key=lambda word: word[0])        # Сортировка по 1-вым символам / буквам.
# print(words)
# words.sort(key=lambda word: word[2])        # Сортировка по 3-тьим символам / буквам.
# print(words)



# %%%%%%%%%%%%%%%%%%%%%%%%%%%_____ THEORY - Methods _____%%%%%%%%%%%%%%%%%%%%%%%%%%%

# _____ Module functools _____
# это модуль, который предоставляет функцию partial, которая позволяет создавать новые функции на
# основе существующих путем фиксирования некоторых аргументов.

# _____Method functools.partial _____                   - Video 0:36:20 -
from functools import partial
# partial() вернет другую функцию, которая будет не запущена.
# Например, можно передать врожденную функцию print() незапущенной, НО в ней можно ЗАМОРОЗИТЬ аргумент/ы.
# Т.е. в partial() передается:
#       1 - то что нужно изменить (например, функция, которая ожидает аргументы),
#       2 - номер аргумента, который нужно заморозить.

# Создание новой функции, которая всегда будет использовать аргумент x = 2
# multiply_by_two = partial(lambda x, y: x * y, 2)      # замораживается аргумент х = 2.
# print(multiply_by_two)
# result = multiply_by_two(5)
# print(result)                                         # Выводит 10.

# Теперь передадим не число, а СТРОКУ в функцию.
# from functools import partial                           # - Video 0:38:50 -
# multiply_by_str = partial(lambda x, y: x + y, '2')    # Выполнится конкатенация.
# result2 = multiply_by_str('5')
# print(result2)                                          # Выводит 25, т.к. х стоит первым, то к нему приставляется 5.

# Теперь заморозим y.
# from functools import partial                           # - Video 0:39:30 -
# multiply_by_str = partial(lambda x, y: x + y, y='2')    # Выполнится конкатенация.
# result2 = multiply_by_str('5')
# print(result2)                                          # Выводит 52, т.к. заморожена последняя переменная -->
                                                          # последнее всегда будет 2, а первое - то что передаем.

# from functools import partial
# print(1, 2, 3, 4, 5, sep='---', end='!\n')              # ! - просто знак.
# print(4, 5, sep='---', end='!\n')
# print("Hello", "World", sep='---', end='!\n')
#
# custom_print = partial(print, sep='---', end='!\n')
# custom_print('Hello', 'World')
# custom_print(1, 2, 3, 4, 5)
#
# custom_print2 = partial(print, 'Values: ', sep='---', end='!\n')
# custom_print2(1, 2, 3, 4, 5)

# Аналог partial:
# def say(a, b, c='!'):
#     print(a, b, c)
# say('Bye', 'Mike')
# say('Hello', 'world', c='.')
# new_say = partial(say, 'Hello', b='Jack')
# new_say()


# %%%%%%%%%%%%%%%%%%%%%%%%%%%_____ THEORY - RECURSION _____%%%%%%%%%%%%%%%%%%%%%%%%%%%     - VIDEO 0:50:00 -

# Рекурсия - это процесс, когда функция вызывает саму себя. - Пример - Лабиринт!
#  __ NB! __  При использовании рекурсии важно определить УСЛОВИЕ ВЫХОДА, чтобы избежать бесконечной рекурсии.
#  __ NB! __  ВСПОМНИТЬ Стек вызовов - Last IN --> First OUT.
# Фрейм (Video 1:15:44) - область памяти, которая выделена для локальной функции, и которая запоминает данные
# этого конкретного вызова. Потому что когда вызывается функция, то каждый раз ей можно передать новые данные.
# Каждый фрейм - отдельный кусок работы программы, которая помнит, какие переменные и с какого места продолжить
# работать по какому-то шаблону функции.

# See М. Б. Игнатьев, Ю. Е. Шейнин, "Рекурсивные вычислительные системы",
# url: https://www.computer-museum.ru/histussr/rvm.htm :
# "Любая ЭВМ в состоянии провести любые вычисления.
# Конкретное же протекание процессов вычисления проявляется лишь на уровне организации преобразований информации:
# задействуются конкретные регистры, коммутаторы, процессоры, линии передачи данных в определенном порядке и сочетании
# и т. д.). С этой точки зрения архитектура ЭВМ – это её структура в состоянии (процессе) реализации алгоритма,
# т. е. как бы ожившая структура. Философской основой такого представления является теория отражения,
# раскрывающая отображение категорий и явлений одной природы (числа, алгоритмы) на объекты другой природы
# (физические элементы, сигналы)".

# __ Пример рекурсивной функции: __
# def countdown(n):
#     if n <= 0:
#         print("Done")                                 # Точка, когда процесс остановится.
#     else:
#         print(n)
#         countdown(n - 1)
# countdown(5)

# _____ Переполнение стека _____ - Бесконечно!
# это процесс, который происходит, если рекурсия не имеет достаточного условия выхода или вызывается
# слишком глубоко. Это означает, что стек вызовов функций полностью заполняется, и программа завершается с ошибкой.
# def countdown(n):
#     print(n)
#     countdown(n - 1)
# countdown(5)                # В Python рекурсия прервется сама, т.к. в Python прописана глубина рекурсии = 999.

# _____ Достоинства и недостатки рекурсии _____
#       +  Рекурсия позволяет разбить сложную задачу на более простые подзадачи и решить их пошагово.
#       -  Рекурсия также может быть неэффективной по памяти и времени, особенно при
#          обработке больших данных или глубокой рекурсии.

# _____ Хвостовая рекурсия _____        - Video 1:12:40 -
# это специальный вид рекурсии, при котором рекурсивный вызов является последней операцией в
# функции. Интерпретатор не оптимизирует хвостовую рекурсию, поэтому использование цикла может быть
# более эффективным способом решения задачи.

# __ Иногда задачу можно решить просто циклом while:
# def countdown(n):
#     while n > 0:
#         print(n)
#         n -= 1
#     print("Done")                                     # Точка, когда процесс остановится.
# countdown(5)

# __ Обычная рекурсия с ПЕРЕПОЛНЕНИЕМ стека:
# def message():
#     print('Это рекурсивная функция')                  # БЕСКОНЕЧНО!
#     message()
# message()

#  __ ХВОСТОВАЯ рекурсия со счетчиком:  5 times.
# def message(times):
#     if times > 0:                                     #  ХВОСТОВАЯ рекурсия со счетчиком:  5 times.
#         print('Это рекурсивная функция')
#         message(times - 1)
# message(5)                                            #  5 раз должна выполниться функция message(times).

# __ НЕ хвостовая рекурсия с хвостовым счетчиком:
# import time
# def message(times):
#     if times > 0:                                       #  __  NB! __  НЕхвостовая рекурсия со счетчиком:  5 times.
#         print('Это рекурсивная функция - ', times)
#         time.sleep(1)
#         message(times - 1)
#         time.sleep(1)
#         print(times)
# message(5)

# __ Другой вариант, когда print(times) сразу после print('Это рекурсивная функция.'):
# def message(times):
#     if times > 0:
#         print('Это рекурсивная функция.')
#         print(times)
#         message(times - 1)
# message(5)

# _____________________________________    Task 1    _____________________________________
# Написать программы, вычисляющие:
#       1) n-е число Фибонначи.
#       2) наибольший общий делитель.
# Задачи решить: с помощью рекурсии и без использования рекурсии.
# Обсудить плюсы и минусы этих подходов.

# __ 1) part __
# def fibonacci_recursive(n):
#     if n == 0:
#         return 0
#     elif n == 1:
#         return 1
#     else:
#         return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
# # 0 1 1 2 3

# print(fibonacci_recursive(3))

# __ 2) part __


# __ Factorial __
# def factorial(n):
#     if n == 1:
#         return 1
#     else:
#         return n * factorial(n - 1)
#
# print(factorial(5))




# _____________________________________    AI 30-01-25, - Task 1    _____________________________________

# Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ...
# (число повторяется столько раз, чему равно). На вход программе передаётся неотрицательное целое число
# n — столько элементов последовательности должна отобразить программа. На выходе ожидается последовательность чисел,
# записанных через пробел в одну строку.
# Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.

# def generate_sequence(n):
#     sequence = []
#     num = 1
#     while len(sequence) < n:
#         sequence.extend([num] * num)  # Добавляем число `num` в список `num` раз
#         num += 1
#     print(*sequence[:n])  # Выводим первые `n` элементов через пробел
#
# # Пример использования:
# n = int(input())  # Вводим количество элементов
# generate_sequence(n)

# _____________________________________    AI - Task 2    _____________________________________

# Попросить ai решить задачу используя 5 разных способов:
# Даются два списка. Нужно избавить первый список от элементов присутствующих во втором,
# сохраняя дубликаты и порядок.
# list1 = [1, 2, 2, 3, 4, 2, 5]
# list2 = [2, 4]
# result = [item for item in list1 if item not in list2]
# print(result)  # Вывод: [1, 3, 5]
