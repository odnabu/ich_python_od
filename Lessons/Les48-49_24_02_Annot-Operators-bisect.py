# Tatiana Kletsovka
# \033[0;__;__m \033[m   or   \033[1;__;__m \033[m
# print('#' * 115)      # Для разделения блоков на листе с кодом:
# ###################################################################################################################
# 24.02.25
# Python 48-49: Аннотации типов. Модуль operator. Бинарный поиск.
# ###################################################################################################################
# Video Lesson 48: https://player.vimeo.com/video/1059656888?h=c84d3188b3.
# Video Practice 49: https://player.vimeo.com/video/1059691061?h=dacfbc0717.

# def input_numb_list():
#     numb_list = [int(x) for x in input('Enter a list of numbers separated by space: ').split()]
#     return numb_list
# ------------------------ SHORTCUTS ------------------------
# Ctrl + W - выделить текущий блок. если нажимать это сочетание дальше, то будут выделяться родительские блоки.
# Ctrl+Y - Удаление всей строки. Кстати, команда копирования Ctrl+C без выделения также работает для всей строки.
# Alt+Enter - Привести код к принятым стандартам (для Python - PEP8).
# Ctrl+R — Изменить название класса/функции и т. п. по всему проекту.
# -----------------------------------------------------------

print('.' * 145)


# ______________________________________  Review of previously covered material  ______________________________________




# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%_____________   Аннотации типов   ______________%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# __________ Аннотации типов __________
# — предоставляют возможность явно указать типы данных для переменных, аргументов функций и возвращаемых значений.
#       ● служат для документирования кода.
#       ● помогают разработчикам и инструментам статического анализа проверять корректность типов.
#       ● не влияют на выполнение кода и являются опциональными.
# Отличие между типами данных и указаниями типов:
#       - Типы данных - Определяют непосредственно характеристики объектов, такие как число, строка или список.
#       - Указания типов в аннотациях - Используются для объявления ожидаемого типа данных в контексте
#         переменных, аргументов функций и возвращаемых значений.

# __________ Синтаксис аннотаций типов __________

# Аннотации типов в Python __записываются__ с использованием двоеточия после имени переменной или
# параметра функции, а затем указывается тип данных.
# __ Example __
# x: int = 5                 # НЕ постулируется, просто мы этого хотим, но передастся тот тип, который действительно введен!
# print(x, type(x))
# s: str = 5
# print(s, type(s))

# Для аргументов и возвращаемых значений функций, аннотации типов __указываются__ в сигнатуре
# функции после имени параметра или после стрелки ( -> ) для возвращаемого значения.
# def add(a: int, b: int) -> int:
#     return a + b
#
# print(add(5, 6))
# print(add(5, '6'))

# def mult(a: int, b: int) -> int:
#     return a * b
#
# print(mult(5, 6))
# print(mult(5, '6'))

# __ NB! __ После -> нужно указывать то, что стоит в ():   str) -> str, тогда worning (желтое предупреждение) о возможной ошибке НЕ будет.
# def mult(a: int, b: str) -> str:
#     return a * b
#
# print(mult(5, '!'))


# ______  Task 1  ____________________________________________________________________________________________________
# Реализуйте функцию word_multiply(). Она должна принимать два параметра:
#   ● Строку.
#   ● Число, которое обозначает, сколько раз нужно повторить строку.
# text = 'python'
# print(word_multiply(text, 2)) # => pythonpython
# print(word_multiply(text, 0)) # =>
# Укажите аннотации типов при объявлении функции.

# def word_multiply(t: str, amount: int) -> str:
#     return t * amount
#
# text = 'python'
# print(word_multiply(text, 2)) # => pythonpython
# print(word_multiply(text, 0)) # =>

# __________ Модуль typing: __________
# — предоставляет дополнительные возможности (вариации) для аннотаций типов. --> Video 48, 38:00

# def word_multiply(t: str, amount: int) -> str:
#     # если текст t существует, т.е. текст не пустой...
#     if t:
#         # ... то вернуть текст умноженный на amount:
#         return t * amount
#     # Иначе вернуть ничего - None.
#     else:
#         return None
#
# text = 'python'
# print(word_multiply(text, 2))     # => pythonpython
# print(word_multiply(text, 0))     # =>

# ___ В модуле typing ___ Video 48, 40:00
#       ● Optional - позволяет указать, что переменная может иметь указанный тип или быть равной None.
#       ● Union - позволяет объединить несколько типов данных в одну аннотацию.
#       ● Any - указывает, что переменная может иметь любой тип данных.

# __ NB! __ ----> Video 48, 40:00
# from typing import Optional, Union, Any       # Из модуля импортировали функкции или...import
# # import typing                               # ... или можно так, но тогда к методам пришлось обращаться ч/з точку: typing.Any
# # typing.Callable - вызываемый объект, т.е. это что мы можем заставить отработать како-то блок кода, т.е. когда
# # функцию передаем в НЕзапущенном виде.
#
# def greet(name: Optional[str]) -> Union[str, int]:
#     if name is None:
#         return "Hello, anonymous"
#     else:
#         return f"Hello, {name}"

# from typing import Any
#
# def process_data(data: Any) -> str:
#     """Принимает данные любого типа и возвращает строку с их представлением."""
#     return f"Данные: {data}"
#
# print(process_data(42), type(process_data(42)))
# print(process_data("Hello"))
# print(process_data([1, 2, 3]))

# ___ Краткая запись Union - ч/з вертикальную черту |   --> Video 48, 48:00
# def calculate(value: int | float) -> float:
#     """Принимает число (целое или дробное) и возвращает его квадрат."""
#     return value ** 2
#
# print(calculate(5))
# print(calculate(2.5))

# __________ Коллекции в typing __________ --> Video 48, 50:00
#   List - для аннотации типа списка.
#   Tuple - для аннотации типа кортежа.
#   Set - для аннотации типа множества.
#   Dict - для аннотации типа словаря.

# from typing import List, Tuple, Set,        Dict,       Union
# #                               Множество   Словарь     Или / Или
#
# def process_data(data: List[str]) -> Tuple[int, Set[str]]:
#     # Обработка данных
#     return len(data), set(data)
#
# # В поздних версиях можно и с маленькой буквы прописывать ожидаемые (т.е. аннотируемые) типы:
# # def process_data(data: list[str]) -> tuple[int, set[str]]:
# #     # Обработка данных
# #     return len(data), set(data)
#
# def get_person_details(person: Dict[str, Union[str, int]]) -> str:
#     # Получение информации о человеке
#     return f"{person['name']}, {person['age']} years old"

# ______ Аннотация возвращаемого генератором типа:
# С помощью модуля typing можно также аннотировать тип данных, возвращаемых генератором.

# from typing import Iterable
#
# def generate_numbers(n: int) -> Iterable[int]:
#     for i in range(n):
#         yield i

# Объясните, что происходит в этом фрагменте кода:     --> Video 48, 58:00
# def broadcast_message(message: str, servers: List[str]) -> None:


# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%_____________   Модуль operator   ______________%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# __________ Модуль operator __________ --> Video 48, 58:00, Python_25_M.pptx-Annot-Operator-bisect.pdf, Slide 29.
# — предоставляет функции, которые позволяют выполнять операции над объектами с помощью операторов.
# Операции над числами и коллекциями через operator
#      - add - сложение,
#      - mul - умножение,
#      - sub - вычитание,
#      - truediv - деление.

# ___ Операции над числами и коллекциями через operator ___
#      - concat - объединение коллекций,
#      - contains - проверка принадлежности элемента,
#      - itemgetter - доступ к элементу.

# __ Example __

# from operator import add, sub, mul, truediv

# result1 = add(5, 3)                          # Результат: 8
# print(result1)
# result2 = sub(10, 2)                         # Результат: 8
# print(result2)
# result3 = mul(2, 4)                          # Результат: 8
# print(result3)
# result4 = truediv(16, 2)                     # Результат: 8.0
# print(result4)

# __________ Функция itemgetter __________ --> Video 48, 1:05:20.
# - позволяет получить доступ (по ключу) к определенному элементу или атрибуту объекта и может быть использована в качестве
#   компаратора при сортировке.

# from operator import itemgetter
#
# data = [
# {'name': 'Alice', 'age': 25},
# {'name': 'Bob', 'age': 30},
# {'name': 'Charlie', 'age': 20}
# ]
# sorted_data = sorted(data, key=itemgetter('age'))     # Формирует НОВЫЙ список, переставив каким-то образом элементы.
# print(sorted_data)

# ______  Task 3  ____________________________________________________________________________________________________
# Объясните, что происходит в этом фрагменте кода:  --> Video 48, 1:11:05.

import operator           # __ NB! __ подгружаем модуль operator.

# Калькулятор:
action = {
    "+": operator.add,
    "-": operator.sub,
    "/": operator.truediv,
    "*": operator.mul,
    "**": operator.pow
}
print(action['-'](50, 25))       # operator.sub  -->  25
print(action['+'](50, 25))       # operator.add  -->  75
print(action['/'](50, 25))       # operator.truediv -->  2.0
print(action['*'](50, 25))       # operator.mul -->  1250


# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%_____________   Модуль bisect   ______________%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# __________ Бинарный поиск __________ - Video 48, 1:13:00
# — эффективный алгоритм поиска элемента в _ТОЛЬКО_ отсортированном списке. Что означает, что можно отсеять половину данных,
# чтобы корректно искать в этих данных.

# __________ Модуль bisect __________  - Video 48, 1:13:05
# — предоставляет функции для выполнения бинарного поиска.
# __ NB! __ Модуль используется не часто, но полезен для понимания работы с некоторыми данными, в некотором роде
# начало логики алгоритмов.
# Например, для ОТСОРТИРОВАННОГО списка с данными: - Video 48, 1:13:40
# [1, 12, 33, 48, 75, 126, 371, 485, 900, 1001]
#  0   1   2   3   4   5    6    7    8     9
# Допустим, я ищу число 485 в этом списке. Далее данные делятся пополам и проверяем СЕРЕДИНУ - 10/2 = 5,
# т.е. проверяем элемент под номером 5 (126) - это не 485. А т.к. 126 < 485, то первую половину списка
# вплоть до 126 отсеиваем. Далее для следующего после 5 индекса 6 и последнего 9 находим: (6+9) / 2 = 7,5 = 7.
# Теперь проверяем элемент с индексом 7: 485 = 485. Поиск завершен и со 2-ой попытки найдено искомое число в
# большом ОТСОРТИРОВАННОМ списке.

# ______ Функции bisect_...: ______
#       ● Функция bisect_left возвращает крайнюю левую позицию, на которую нужно вставить элемент, чтобы
#         сохранить порядок сортировки списка.
#       ● Функция bisect_right возвращает крайнюю правую позицию, на которую нужно вставить элемент, чтобы
#         сохранить порядок сортировки списка.

# from bisect import bisect_left, bisect_right
# data1 = [1, 3, 5, 7, 9]
# data2 = [1, 3, 6, 7, 9]
# index1 = bisect_left(data1, 6)        # Результат: 3
# print(index1)
# index2 = bisect_right(data1, 6)       # Результат: 3
# print(index2)
# index3 = bisect_left(data2, 6)        # Результат: 2
# print(index3)
# index4 = bisect_right(data2, 6)       # Результат: 3
# print(index4)

# ______  Task 4  ____________________________________________________________________________________________________
# Предположите, какое условие задачи может быть, если ему соответствует следующее решение? Video 48, 1:25

# from bisect import bisect_left, bisect_right
#
# #                                 F    D   C   B  A         __ NB! __ вариантов Оценок должно быть больше, чем Границ!
# def grade_right(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
#     i = bisect_right(breakpoints, score)
#     return grades[i]
# print("grade_right: ", [grade_right(score) for score in [33, 99, 77, 70, 89, 90, 100]])      # ['F', 'A', 'C', 'C', 'B', 'A', 'A']
#
# #                                 F   D   C   B  A
# def grade_left(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
#     i = bisect_left(breakpoints, score)
#     return grades[i]
#
# print("grade_left: ", [grade_left(score) for score in [33, 99, 77, 70, 89, 90, 100]])


# ______  Task 5  ____________________________________________________________________________________________________
# 1. Напишите функцию, которая принимает список строк и возвращает наибольшую строку из списка.
# Функция должна быть аннотирована с помощью аннотаций типов.



# ______  Task 6  ____________________________________________________________________________________________________
# 2. Напишите функцию, которая принимает список словарей и ключ, по которому нужно отсортировать список словарей.
# Функция должна быть аннотирована с помощью аннотаций типов. --> Video 49.

# # typing: Any                   # The SAME!!!
# from typing import Any          # The SAME!!!
# from operator import itemgetter
#
# #                          |--> Аннотация к типу данных в users_data.
# #                          |                               |-->Аннотация к типу данных в ключе.
# def sort_dict(users_data: list[dict[str, Any]], key_fact: str) -> list[dict[str, Any]]:
#     return sorted(users_data, key=itemgetter(key_fact))
#
# data = [
# {'name': 'Alice', 'age': 25},
# {'name': 'Bob', 'age': 30},
# {'name': 'Charlie', 'age': 20}
# ]
#
# print(sort_dict(data, 'age'))

# ______  Task 7  ____________________________________________________________________________________________________
# 3. Напишите функцию, которая принимает список строк и возвращает словарь, где ключи — строки, а значения — длина этих строк.
# Добавьте документацию и аннотации типов для всех параметров и возвращаемого значения.

# def convert_str_to_dict(strings_list: list[str]) -> dict[str, int]:
#     return {strings_list: len(strings_list) for strings_list in strings_list}
#
# # data = ['123', '2345', '345678', '444', '55', '6666', '7', '8', '9', '10']
# data = ["apple", "banana", "cherry", "date", "elderberry", "fig", "grape", "honeydew", "jackfruit", "kiwi"]
# print(convert_str_to_dict(data))


# ______  Task 8  ____________________________________________________________________________________________________
# 4. Напишите функцию, которая принимает имя пользователя и необязательный список его достижений.
# Если список пуст, возвращается сообщение "Нет достижений". Если список не пуст, возвращается строка с перечислением достижений.
# Добавьте документацию и аннотации типов для всех параметров и возвращаемого значения.


# ______  Task 9  ____________________________________________________________________________________________________
# 5. Напишите генератор, который принимает на вход поток элементов и выдает только уникальные элементы,
# сохраняя их порядок встречаемости (для уже повторяющихся элементов генератор не выдает ничего).
# Вывод в порядке передачи.

# Т.к. поток, то поначалу лучше оставить пустые скобки.

# from typing import Iterable
#
# def generate_unique_elements():             #  -> Iterable[int | None]:
#     try:
#         temp = []
#         digit = yield
#         while True:
#             if digit not in temp:
#                 temp.append(digit)
#                 digit = yield digit             # Video 49, 1:20 yield - возвращает из функции / принимает в функцию.
#             else:
#                 digit =  None # yield None
#     except GeneratorExit:
#         print(temp)
#
# gen = generate_unique_elements()
# next(gen)                               # The SAME!!!           # next() - ВСЕГДА отдаёт.
# # gen.__next__()                        # The SAME!!!
# for i in range(3):
#     user_input = int(input("Enter a number: "))
#     print(gen.send(user_input))                           # Video 49, 53:35 - для выведения каждый раз этого элемента или
                                                            # None, если его нет - нужно делать gen.send(). + 1:17:00
# gen.close()                              # Закрыть генератор, т.е. прервать работу генератора.


# __ NB! __ Пошаговое отслеживание работы программы с ДЕБАГОМ:

from typing import Iterable

# def generate_unique_elements():             #  -> Iterable[int | None]:
#     temp = []
#     digit = yield
#     while True:
#         if digit not in temp:
#             temp.append(digit)
#             digit = yield digit * 2             # 1:20 yield - возвращает из функции / принимает в функцию.
#             print("---------------")
#         else:
#             digit =  yield None # yield None
#             print("END of code END of code END of code")
#
# gen = generate_unique_elements()
# next(gen)                               # The SAME!!!           # next() - ВСЕГДА отдаёт.
# # gen.__next__()                        # The SAME!!!
# print(next(gen))
# for i in range(3):
#     user_input = int(input("Enter a number: "))
#     print(gen.send(user_input))             # Video 49, 1:32:00 - ?????????????????????????? + 1:47:00 --> send направляет на 363 строку и ЖДЁТ результат из yield в 367!  ??????????????????

